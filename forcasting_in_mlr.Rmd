---
title: "Forecasting in mlr"
author: "Steve Bronder"
date: "January 2nd, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

As of December 1st, 2016, the forecasting extension of mlr is under code review and is a branch of the development version of mlr. You can download this branch through the `githubinstall` package.

```{r getforemlr, eval = FALSE}
library(githubinstall)
gh_install_packages("mlr-org/mlr", ref = "forecasting")
```

## Forecasting

The standard objective in forecasting is, at time period $t$, make predictions for $t+h$ periods into the future. Forecasting tasks are most suitable when past patterns in the data will continue on into the future. While R has many wonderful packages for forecasting, there is no package on CRAN that gives users a standardized form for forecasting models, such as `mlr` and `caret` for machine learning models. The purpose of this package extension is to give users of `mlr` the opportunity to safely and productively train, optimize, and deploy forecasting models.

## Forecasting Tasks

For our purposes we will simulate some data.

```{r makedata, cache = TRUE}
set.seed(1234)
dat = arima.sim(model = list(ar = c(.5,.2), ma = c(.4), order = c(2,0,1)), n = 200)
times = (as.POSIXlt("1992-01-14")) + lubridate::days(1:200)
dat = xts::xts(dat,order.by = times)
colnames(dat) = c("arma_test")
dat.train = dat[1:190,]
dat.test = dat[191:200,]
```

To specify a forecast task we must pass an `xts` object containing the data, a `target`, and the `frequency` of the data. The frequency of the data can be thought of as the seasonality. For example, a frequency of seven on daily data would be a weekly seasonality. A frequency of fifty-two on weekly data would indicate a yearly seasonality.

```{r makeTask, cache = TRUE}
library(mlr)
fcregr.task = makeForecastRegrTask(id = "test", data = dat.train, target = "arma_test",
                                     frequency = 7L)
fcregr.task
```


Like a regression task, this records the type of the learning problem and basic information about the data set. This task also returns the start and end dates of the time series as well as the frequency.

## Multivariate Forecasting Tasks

One common problem with forecasting is that it is difficult to use additional explanatory variables or forecast multiple targets that are dependent on one another. If we are at time $t$ and want to forecast 10 periods in the future, we need to know the values of the explanatory variables at time $t+10$, which is often not possible. A new set of models which treats explanatory variables endogenously instead of exogenously allows us to forecast not only our target, but additional explanatory variables. This is done by treating all the variables as targets, making them endogenous to the model. To use these models, we create a multivariate forecasting task.

```{r EuStockData, cache = TRUE}
data("EuStockMarkets")
EuStockMarkets.time = lubridate::date_decimal(as.numeric(time(EuStockMarkets)))
EuStockMarkets  = xts::xts(as.data.frame(EuStockMarkets), order.by = EuStockMarkets.time)
EuStockMarkets.train = EuStockMarkets[1:1850,]
EuStockMarets.test = EuStockMarkets[1851:1860,]
mfcregr.task = makeMultiForecastRegrTask(id = "bigvar", data = EuStockMarkets.train, target = "all", frequency = 7L)
mfcregr.task
```

This task prints the same information as a univariate forecast task.

If we would like to specify a target variable while still forecasting the rest of the data in an endogenous manner, we change our target to one of the variables.

```{r EuStockDataSingle, cache = TRUE}
mfcregr.task = makeMultiForecastRegrTask(id = "bigvar", data = EuStockMarkets.train, target = "DAX", frequency = 7L)
mfcregr.task
```

## Making Learners for Forecasting

Several new models have been included from the `forecast` package and well as `rugarch`:

1. Exponential smoothing state space model with Box-Cox transformation (bats)
2. Exponential smoothing state space model with Box-Cox transformation, ARMA errors, Trend and Seasonal Fourier components (tbats)
3. Exponential smoothing state space model (ets)
4. Neural Network Autoregressive model (nnetar)
5. Automated Arima (auto.arima)
6. General Autoregressive Conditional Heteroskedasticity models (GARCH)
7. BigVar for multivariate time series

These all operate the same as the other models in mlr, with a very important parameter. Models will either have an `h` or `n.ahead` parameter, which is the number of periods you want to forecast into the future. Note that this should be equal to the horizon you set in your growing or fixed window resampling strategy. 

We create a GARCH model from the package `rugarch` using `makeLearner()` by calling the learner class `fcregr.garch`. An important parameter is the `n.ahead` parameter, which is used to specify that we are forecasting 10 periods into the future. We can view all of the possible parameters that can be tuned with `getLearnerParamSet("fcregr.garch")`

```{r makeArima, cache = TRUE}
garch.mod = makeLearner("fcregr.garch",
                        model = "sGARCH", garchOrder = c(2,1),
                        n.ahead = 10L, include.mean = FALSE)
garch.mod
```

Once we set up our task and model `train()`, `predict()`, and `performance()` can be called to build and evaluate the model.

```{r garchMod, cache = TRUE}
garch.train = train(garch.mod, fcregr.task)
garch.pred = predict(garch.train, newdata = dat.test)
performance(garch.pred, measure = mase, task = fcregr.task, model = garch.train)
```

This standard evaluation method is user friendly and in addition, we can now use `mlr`'s built in resampling and tuning methods to tune a garch model for the data.

## Resampling

mlr now has two new cross validation resampling strategies, `GrowingCV` and `FixedCV`. They are both rolling forecasting origin techniques established in Hyndman and Athanasopoulos (2013) and first widely available for machine learning in R by the `caret` packageâ€™s `createTimeSlices()` function. We specify:

1. horizon - the number of periods to forecast
2. initial.window - The proportion of data that will be used in the initial window
3. size - The number of rows in the training set
4. skip - the proportion of windows to skip over, which can be used to save time

```{r resampleDescSimp, cache = TRUE}
resamp.desc = makeResampleDesc("GrowingCV", horizon = 10L,
                               initial.window = .90)
resamp.desc

```

Note that we should not specify stratification, as it does not really make sense in the context of time series to stratify our data (unless a future implementation can somehow use this for panel data). The wonderful graphic posted below comes from the `caret` package's website and gives an intuitive idea of the sliding windows for both the growing and fixed options.

![The top two graphs correspond to fixed window while the bottom two graphs are for growing window](windowing.png)

Using the resampling strategy we can do a windowing cross-validation with our previous GARCH model to evaluate the general performance of the created GARCH model.

```{r resampleGarch, cache = TRUE}
garch.resample = resample(learner = garch.mod, task = fcregr.task,
                          resampling = resamp.desc, measures = mase)
garch.resample
```

## Tuning

The forecasting features fully integrate into mlr, allowing us to also make a parameter set to tune over. Here we tune a GARCH model with F1-racing used to tune our parameters. In addition, we can tune the model in parallel using `parallelMap`.

```{r tuneArima, cache = TRUE, eval = FALSE}
par_set = makeParamSet(
  makeDiscreteParam(id = "model", values = c("sGARCH", "fGARCH")),
  makeDiscreteParam(id = "submodel", values = c("GARCH", "NGARCH"),
                    requires = quote(model == "fGARCH")),
  makeIntegerVectorParam(id = "garchOrder", len = 2L, lower = 1, upper = 3))

#Specify tune by Irace
ctrl = makeTuneControlIrace(maxExperiments = 180L)

library(parallelMap)
parallelStartSocket(6)
configureMlr(on.learner.error = "warn")
res = tuneParams(garch.mod, task = fcregr.task,
                 resampling = resamp.desc, par.set = par_set,
                 control = ctrl, measures = mase)
parallelStop()
res
```

```{r garchTunesave, eval =FALSE, echo = FALSE}
save(res, file = "./garch_tune.RData")
```

```{r garchTuneReal, eval =TRUE, echo = FALSE}
load("./garch_tune.RData")
res
```


Once we have tuned the model we get back the hyperparameters of the best model through `setHyperPars()` and then train the model like any other.

```{r bestArima, cache = TRUE}
garch.hyp  = setHyperPars(makeLearner("fcregr.garch", n.ahead = 10L),
                          par.vals = res$x)
garch.best = train(garch.hyp, fcregr.task)
garch.pred = predict(garch.best, newdata = dat.test)
performance(garch.pred, measures = mase, task = fcregr.task, model = garch.train)

```

## Updating Models

A new function `updateModel()` has been implemented that updates the model given new data. This function is currently only implemented for ets, Arima, auto.arima, bats, tbats, and nnetar.

```{r updateArima, cache = TRUE}
fcregr.task = makeForecastRegrTask(id = "test", data = dat.train,
                                   target = "arma_test", frequency = 7L)
arm = makeLearner("fcregr.Arima", order = c(2L,0L,1L),
                  h = 10L, include.mean = FALSE)
arm
armMod = train(arm, fcregr.task)
updateArmMod = updateModel(armMod, fcregr.task, newdata = dat.test)
updateArmMod

```

This works by making a call to `updateLearner.fcregr.Arima()` and updating the model and task data with newdata. `predict()` now forcasts the next 10 periods.

```{r armaUpdatePred, cache = TRUE}

predict(updateArmMod, task = fcregr.task)
```

## Pre-processing
### Creating Lags and Differences

The function `createLagDiffFeatures()` allows users to create arbitrary lags and differences that allow for the creation of $AR(p,d)$ style machine learning models to be used with forecasting. This method requires passing a data frame with the row names being POSIXct compatable.

```{r createlagdiff, cache = TRUE}
library(xts)
library(lubridate)
date.col = as.POSIXct(index(dat.train))
dat.train.reg = as.data.frame(dat.train)
regr.task = makeRegrTask(data = dat.train.reg, target = "arma_test")
regr.task.lag = createLagDiffFeatures(regr.task,lag = 2L:4L, difference = 1L, 
                                          seasonal.lag = 1L:2L, frequency = 5, date.col = date.col)
regr.task.lag

```

This can be used with any task type as long as the row names of the task data can be converted to `POSIXct` format. 

As an example, we will build and train a gradient boosting machine using lagged data.

```{r gdmLags, cache = TRUE}
regrGbm <- makeLearner("regr.gbm", par.vals = list(n.trees = 100))
gbm.mod = train(regrGbm, regr.task.lag)

```

To forecast with a regression model whose task is manipulated by `createLagDiffFeatures()` use the function `forecast()`.

```{r forecastgbm, cache = TRUE}
gbm.fore = forecast(gbm.mod, h = 10, newdata = dat.test)
performance(gbm.fore, measures = mase, task = regr.task.lag, model = gbm.mod)
```


## Classification Forecasting Example

For developing trading strategies, we normally have a discrete set of choices such as to buy, sell, or hold onto a stock. Using forecasting in mlr we can now train classification models that forecast these choices. He we try to predict whether a 'stock' will go up 5%, down 5%, or neither. Below we simulate data from an ARIMA process, take the percentage change, and descritize the data into either a 'buy', 'sell', or 'hold'.

```{r binaryforecast, cache = TRUE}
library(xts)
library(lubridate)
set.seed(1234)
# Generate an ARIMA based data set
dat = arima.sim(model = list(ar = c(.5,.2,.1), ma = c(.5,.3), order = c(3,0,2)), n = 500)
dat = dat/lag(dat,-1) - 1 
jump = data.frame(jump = ifelse(diff(dat) > .5, "Buy",ifelse(diff(dat) < -.5, "Sell","Hold")))
times = (as.POSIXct("1992-01-14")) + lubridate::days(1:498)
rownames(jump) = times
jump.train = jump[1:488,,drop = FALSE]
jump.test  = jump[489:498,,drop = FALSE]

# Make the classif task
classif.task = makeClassifTask(data = jump.train,target = "jump")
classif.task.lag = createLagDiffFeatures(classif.task, lag = 1L:15L, 
                                         date.col = times[1:488])

classif.learn = makeLearner("classif.boosting")
classif.train = train(classif.learn,classif.task.lag)
classif.fore = forecast(classif.train, h = 10, newdata = jump.test)
performance(classif.fore)
```

So our model does pretty bad, but that is because it was not tuned. Given the structure in mlr, parallel computing, and time, it would be possible to use this type of model to make forecast classifiers.

## Ensembles of Forecasts

Itâ€™s known that ensembles of forecasts tend to outperform standard forecasting techniques. Here we use mlrâ€™s stacked modeling functionality to ensemble multiple forecast techniques.

```{r forecastBlend, cache = TRUE}
# Create some data
library(xts)
library(lubridate)
dat = arima.sim(model = list(ar = c(.5,.2), ma = c(.4), order = c(2,0,1)), n = 500)
times = (as.POSIXlt("1992-01-14")) + lubridate::days(1:500)
dat = xts(dat,order.by = times)
colnames(dat) = c("arma_test")

# seperate into test and train
dat.train = dat[1:490,]
dat.test  = dat[491:500,]

fcregr.task = makeForecastRegrTask(id = "test", data = dat.train, target = "arma_test",
                                     frequency = 7L)
                                     
resamp.sub = makeResampleDesc("GrowingCV",
                          horizon = 10L,
                          initial.window = .90
                          )
                          
resamp.super = makeResampleDesc("CV", iters = 5)

lrns = makeLearners(c("fcregr.tbats","fcregr.garch"))

                            
stack.forecast = makeStackedLearner(base.learners = lrns,
                       predict.type = "response",
                       method = "average")

# Simple param set for tuning sub learners
ps = makeParamSet(
  makeDiscreteParam("fcregr.tbats.h", values = 10),
  makeDiscreteParam("fcregr.garch.n.ahead", values = 10)
)

## tuning
fore.tune = tuneParams(stack.forecast, fcregr.task, resampling = resamp.sub,
                   par.set = ps, control = makeTuneControlGrid(),
                   measures = mase, show.info = FALSE)
fore.tune
# get hyper params
stack.forecast.tune  = setHyperPars2(stack.forecast,fore.tune$x)
stack.forecast.tune
# Train the final best models and predict
stack.forecast.mod = train(stack.forecast.tune,fcregr.task)
stack.forecast.pred = predict(stack.forecast.mod, newdata = dat.test)
stack.forecast.pred

```

Please note that this an experimental branch of mlr. Please direct any issues to mlr's issue tracker on github